/**************************************************************************************************
 * 
 * \file epwm.h
 * 
 * \brief ePWM driverlib interface
 * 
 * \author Marko Gulin
 * 
 *************************************************************************************************/

#ifndef EPWM_H
#define EPWM_H

#include "inc/hw_epwm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"

#include "cpu.h"
#include "debug.h"

#include <stdint.h>
#include <stdbool.h>

/**************************************************************************************************
 * 
 * Defines for the API
 * 
 *************************************************************************************************/

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setEmulationMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_EMULATION_STOP_AFTER_NEXT_TB = 0,      /* Stop after next time-base counter tick       */
    EPWM_EMULATION_STOP_AFTER_FULL_CYCLE = 1,   /* Stop when counter completes whole cycle      */
    EPWM_EMULATION_FREE_RUN = 2                 /* Free run                                     */
} EPWM_EmulationMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setCountModeAfterSync() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_COUNT_MODE_DOWN_AFTER_SYNC = 0,        /* Count down after sync event                  */
    EPWM_COUNT_MODE_UP_AFTER_SYNC = 1           /* Count up after sync event                    */
} EPWM_SyncCountMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setClockPrescaler() as the \e clkdiv parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_CLOCK_DIVIDER_1   = 0,                 /* Divide clock by 1 (default on reset)         */
    EPWM_CLOCK_DIVIDER_2   = 1,                 /* Divide clock by 2                            */
    EPWM_CLOCK_DIVIDER_4   = 2,                 /* Divide clock by 4                            */
    EPWM_CLOCK_DIVIDER_8   = 3,                 /* Divide clock by 8                            */
    EPWM_CLOCK_DIVIDER_16  = 4,                 /* Divide clock by 16                           */
    EPWM_CLOCK_DIVIDER_32  = 5,                 /* Divide clock by 32                           */
    EPWM_CLOCK_DIVIDER_64  = 6,                 /* Divide clock by 64                           */
    EPWM_CLOCK_DIVIDER_128 = 7                  /* Divide clock by 128                          */
} EPWM_ClockDivider;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setClockPrescaler() as the \e hspclkdiv parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_HSCLOCK_DIVIDER_1  = 0,                /* Divide clock by 1                            */
    EPWM_HSCLOCK_DIVIDER_2  = 1,                /* Divide clock by 2 (default on reset)         */
    EPWM_HSCLOCK_DIVIDER_4  = 2,                /* Divide clock by 4                            */
    EPWM_HSCLOCK_DIVIDER_6  = 3,                /* Divide clock by 6                            */
    EPWM_HSCLOCK_DIVIDER_8  = 4,                /* Divide clock by 8                            */
    EPWM_HSCLOCK_DIVIDER_10 = 5,                /* Divide clock by 10                           */
    EPWM_HSCLOCK_DIVIDER_12 = 6,                /* Divide clock by 12                           */
    EPWM_HSCLOCK_DIVIDER_14 = 7,                /* Divide clock by 14                           */
} EPWM_HSClockDivider;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setSyncOutPulseMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_SYNC_OUT_PULSE_ON_SOFTWARE = 0,            /* Sync pulse is generated by software      */
    EPWM_SYNC_OUT_PULSE_ON_EPWMxSYNCIN = 0,         /* Sync pulse is passed from EPWMxSYNCIN    */
    EPWM_SYNC_OUT_PULSE_ON_COUNTER_ZERO = 1,        /* Pulse when time-base counter equals zero */
    EPWM_SYNC_OUT_PULSE_ON_COUNTER_COMPARE_B = 2,   /* Pulse when time-base counter equals CMPB */
    EPWM_SYNC_OUT_PULSE_DISABLED = 3,               /* Sync pulse is disabled                   */
} EPWM_SyncOutPulseMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setPeriodLoadMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_PERIOD_SHADOW_LOAD = 0,    /* PWM period register access is through shadow register    */
    EPWM_PERIOD_DIRECT_LOAD = 1     /* PWM period register access is direct                     */
} EPWM_PeriodLoadMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setTimeBaseCounterMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_COUNTER_MODE_UP = 0,               /* Up-count mode                                    */
    EPWM_COUNTER_MODE_DOWN = 1,             /* Down-count mode                                  */
    EPWM_COUNTER_MODE_UP_DOWN = 2,          /* Up-down-count mode                               */
    EPWM_COUNTER_MODE_STOP_FREEZE = 3       /* Stop-freeze counter operation (default on reset) */
} EPWM_TimeBaseCountMode;

/**************************************************************************************************
 * 
 * Values returned by \e EPWM_getTimeBaseCounterDirection()
 * 
 *************************************************************************************************/

#define EPWM_TIME_BASE_STATUS_COUNT_DOWN    0U
#define EPWM_TIME_BASE_STATUS_COUNT_UP      1U

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_getCounterCompareShadowStatus(),
 * \e EPWM_setCounterCompareValue(), \e EPWM_setCounterCompareShadowLoadMode(), and
 * \e EPWM_disableCounterCompareShadowLoadMode() as the \e module parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_COUNTER_COMPARE_A = 0,             /* Counter compare A module                         */
    EPWM_COUNTER_COMPARE_B = 1              /* Counter compare B module                         */
} EPWM_CounterCompareModule;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setCounterCompareShadowLoadMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_COMP_LOAD_ON_CNTR_ZERO = 0,                /* Load when counter equals zero            */
    EPWM_COMP_LOAD_ON_CNTR_PERIOD = 1,              /* Load when counter equals period          */
    EPWM_COMP_LOAD_ON_CNTR_ZERO_PERIOD = 2,         /* Load when counter equals zero or period  */
    EPWM_COMP_LOAD_FREEZE = 3                       /* Freeze shadow to active load             */
} EPWM_CounterCompareLoadMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierAction() as the \e event parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO      = 0,   /* Time-base counter equals zero                */
    EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD    = 2,   /* Time-base counter equals period              */
    EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPA   = 4,   /* Time-base counter equals CMPA on up-count    */
    EPWM_AQ_OUTPUT_ON_TIMEBASE_DOWN_CMPA = 6,   /* Time-base counter equals CMPA on down-count  */
    EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPB   = 8,   /* Time-base counter equals CMPB on up-count    */
    EPWM_AQ_OUTPUT_ON_TIMEBASE_DOWN_CMPB = 10   /* Time-base counter equals CMPB on down-count  */
} EPWM_ActionQualifierOutputEvent;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierAction() and
 * \e EPWM_setActionQualifierSWAction() as the \e output parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_OUTPUT_NO_CHANGE = 0x0U,            /* No change in output pin                      */
    EPWM_AQ_OUTPUT_LOW       = 0x1U,            /* Force output pin to low                      */
    EPWM_AQ_OUTPUT_HIGH      = 0x2U,            /* Force output pin to high                     */
    EPWM_AQ_OUTPUT_TOGGLE    = 0x3U             /* Toggle output pin state                      */
} EPWM_ActionQualifierOutput;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierContSWForceAction() as the \e output
 * parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_SW_DISABLED    = 0x0U,              /* Software forcing disabled                    */
    EPWM_AQ_SW_OUTPUT_LOW  = 0x1U,              /* Force output pin to low                      */
    EPWM_AQ_SW_OUTPUT_HIGH = 0x2U               /* Force output pin to high                     */
} EPWM_ActionQualifierSWOutput;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierActionComplete() as the \e action
 * parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_OUTPUT_NO_CHANGE_ZERO       = 0x0000U,  /* Do nothing on ZRO event                  */
    EPWM_AQ_OUTPUT_LOW_ZERO             = 0x0001U,  /* Force ePWM output low on ZRO event       */
    EPWM_AQ_OUTPUT_HIGH_ZERO            = 0x0002U,  /* Force ePWM output high on ZRO event      */
    EPWM_AQ_OUTPUT_TOGGLE_ZERO          = 0x0003U,  /* Toggle ePWM output state on ZRO event    */
    EPWM_AQ_OUTPUT_NO_CHANGE_PERIOD     = 0x0000U,  /* Do nothing on PRD event                  */
    EPWM_AQ_OUTPUT_LOW_PERIOD           = 0x0004U,  /* Force ePWM output low on PRD event       */
    EPWM_AQ_OUTPUT_HIGH_PERIOD          = 0x0008U,  /* Force ePWM output high on PRD event      */
    EPWM_AQ_OUTPUT_TOGGLE_PERIOD        = 0x000CU,  /* Toggle ePWM output state on PRD event    */
    EPWM_AQ_OUTPUT_NO_CHANGE_UP_CMPA    = 0x0000U,  /* Do nothing on CAU event                  */
    EPWM_AQ_OUTPUT_LOW_UP_CMPA          = 0x0010U,  /* Force ePWM output low on CAU event       */
    EPWM_AQ_OUTPUT_HIGH_UP_CMPA         = 0x0020U,  /* Force ePWM output high on CAU event      */
    EPWM_AQ_OUTPUT_TOGGLE_UP_CMPA       = 0x0030U,  /* Toggle ePWM output state on CAU event    */
    EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_CMPA  = 0x0000U,  /* Do nothing on CAD event                  */
    EPWM_AQ_OUTPUT_LOW_DOWN_CMPA        = 0x0040U,  /* Force ePWM output low on CAD event       */
    EPWM_AQ_OUTPUT_HIGH_DOWN_CMPA       = 0x0080U,  /* Force ePWM output high on CAD event      */
    EPWM_AQ_OUTPUT_TOGGLE_DOWN_CMPA     = 0x00C0U,  /* Toggle ePWM output state on CAD event    */
    EPWM_AQ_OUTPUT_NO_CHANGE_UP_CMPB    = 0x0000U,  /* Do nothing on CBU event                  */
    EPWM_AQ_OUTPUT_LOW_UP_CMPB          = 0x0100U,  /* Force ePWM output low on CBU event       */
    EPWM_AQ_OUTPUT_HIGH_UP_CMPB         = 0x0200U,  /* Force ePWM output high on CBU event      */
    EPWM_AQ_OUTPUT_TOGGLE_UP_CMPB       = 0x0300U,  /* Toggle ePWM output state on CBU event    */
    EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_CMPB  = 0x0000U,  /* Do nothing on CBD event                  */
    EPWM_AQ_OUTPUT_LOW_DOWN_CMPB        = 0x0400U,  /* Force ePWM output low on CBD event       */
    EPWM_AQ_OUTPUT_HIGH_DOWN_CMPB       = 0x0800U,  /* Force ePWM output high on CBD event      */
    EPWM_AQ_OUTPUT_TOGGLE_DOWN_CMPB     = 0x0C00U   /* Toggle ePWM output state on CBD event    */
} EPWM_ActionQualifierEventAction;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierAction(),
 * \e EPWM_setActionQualifierActionComplete(), \e EPWM_setActionQualifierSWAction(),
 * \e EPWM_setActionQualifierContSWForceAction(), and \e EPWM_forceActionQualifierSWAction()
 * as the \e type parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_OUTPUT_A = 0,           /* ePWMxA output                                            */
    EPWM_AQ_OUTPUT_B = 1            /* ePWMxB output                                            */
} EPWM_ActionQualifierOutputModule;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setActionQualifierContSWForceShadowMode() as the \e mode
 * parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_AQ_SW_SH_LOAD_ON_CNTR_ZERO        = 0x0U,  /* Load when counter equals zero            */
    EPWM_AQ_SW_SH_LOAD_ON_CNTR_PERIOD      = 0x1U,  /* Load when counter equals period          */
    EPWM_AQ_SW_SH_LOAD_ON_CNTR_ZERO_PERIOD = 0x2U,  /* Load when counter equals zero or period  */
    EPWM_AQ_SW_IMMEDIATE_LOAD              = 0x3U   /* Load immediately, no shadowing           */
} EPWM_ActionQualifierContForce;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDeadBandDelayPolarity() and
 * \e EPWM_setDeadBandDelayMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DB_FED = 0,                        /* Dead-band rising-edge delay (RED) mode           */
    EPWM_DB_RED = 1                         /* Dead-band falling-edge delay (FED) mode          */
} EPWM_DeadBandDelayMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDeadBandDelayPolarity() as the \e polarity parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DB_POLARITY_ACTIVE_HIGH = 0,       /* Dead-band polarity is not inverted               */
    EPWM_DB_POLARITY_ACTIVE_LOW  = 1        /* Dead-band polarity is inverted                   */
} EPWM_DeadBandPolarity;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setRisingEdgeDeadBandDelayInput() and
 * \e EPWM_setFallingEdgeDeadBandDelayInput() as the \e input parameter.
 * 
 *************************************************************************************************/

#define EPWM_DB_INPUT_EPWMA         0U
#define EPWM_DB_INPUT_EPWMB         1U

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDeadBandCounterClock() as the mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DB_COUNTER_CLOCK_FULL_CYCLE = 0,   /* Dead-band counter runs at TBCLK rate             */
    EPWM_DB_COUNTER_CLOCK_HALF_CYCLE = 1    /* Dead-band counter runs at 2*TBCLK rate           */
} EPWM_DeadBandClockMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_enableTripZoneSignals() and
 * \e EPWM_disableTripZoneSignals() as the \e signal parameter.
 * 
 *************************************************************************************************/

#define EPWM_TZ_SIGNAL_CBC1         0x0001U     /* TZ1 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_CBC2         0x0002U     /* TZ2 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_CBC3         0x0004U     /* TZ3 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_CBC4         0x0008U     /* TZ4 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_CBC5         0x0010U     /* TZ5 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_CBC6         0x0020U     /* TZ6 cycle by cycle                           */
#define EPWM_TZ_SIGNAL_DCAEVT2      0x0040U     /* DCAEVT2 cycle by cycle                       */
#define EPWM_TZ_SIGNAL_DCBEVT2      0x0080U     /* DCBEVT2 cycle by cycle                       */
#define EPWM_TZ_SIGNAL_OSHT1        0x0100U     /* One-shot TZ1                                 */
#define EPWM_TZ_SIGNAL_OSHT2        0x0200U     /* One-shot TZ2                                 */
#define EPWM_TZ_SIGNAL_OSHT3        0x0400U     /* One-shot TZ3                                 */
#define EPWM_TZ_SIGNAL_OSHT4        0x0800U     /* One-shot TZ4                                 */
#define EPWM_TZ_SIGNAL_OSHT5        0x1000U     /* One-shot TZ5                                 */
#define EPWM_TZ_SIGNAL_OSHT6        0x2000U     /* One-shot TZ6                                 */
#define EPWM_TZ_SIGNAL_DCAEVT1      0x4000U     /* One-shot DCAEVT1                             */
#define EPWM_TZ_SIGNAL_DCBEVT1      0x8000U     /* One-shot DCBEVT1                             */

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setTripZoneDigitalCompareEventCondition() as the \e output
 * parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_TZ_DC_OUTPUT_A1 = 0,                   /* Digital compare output 1 A                   */
    EPWM_TZ_DC_OUTPUT_A2 = 3,                   /* Digital compare output 2 A                   */
    EPWM_TZ_DC_OUTPUT_B1 = 6,                   /* Digital compare output 1 B                   */
    EPWM_TZ_DC_OUTPUT_B2 = 9                    /* Digital compare output 2 B                   */
} EPWM_TripZoneDigitalCompareOutput;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setTripZoneDigitalCompareEventCondition() as the \e event
 * parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_TZ_EVENT_DC_DISABLED        = 0,       /* Event is disabled                            */
    EPWM_TZ_EVENT_DCXH_LOW           = 1,       /* Event when DCxH low, DCxL don't care         */
    EPWM_TZ_EVENT_DCXH_HIGH          = 2,       /* Event when DCxH high, DCxL don't care        */
    EPWM_TZ_EVENT_DCXL_LOW           = 3,       /* Event when DCxL low, DCxH don't care         */
    EPWM_TZ_EVENT_DCXL_HIGH          = 4,       /* Event when DCxL high, DCxH don't care        */
    EPWM_TZ_EVENT_DCXL_HIGH_DCXH_LOW = 5        /* Event when DCxL high, DCxH low               */
} EPWM_TripZoneDigitalCompareOutputEvent;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setTripZoneAction() as the \e event parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_TZ_ACTION_EVENT_TZA     = 0,           /* TZ1-TZ6, DCAEVT2, DCAEVT1                    */
    EPWM_TZ_ACTION_EVENT_TZB     = 2,           /* TZ1-TZ6, DCBEVT2, DCBEVT1                    */
    EPWM_TZ_ACTION_EVENT_DCAEVT1 = 4,           /* DCAEVT1 (Digital compare A event 1)          */
    EPWM_TZ_ACTION_EVENT_DCAEVT2 = 6,           /* DCAEVT2 (Digital compare A event 2)          */
    EPWM_TZ_ACTION_EVENT_DCBEVT1 = 8,           /* DCBEVT1 (Digital compare B event 1)          */
    EPWM_TZ_ACTION_EVENT_DCBEVT2 = 10           /* DCBEVT2 (Digital compare B event 2)          */
} EPWM_TripZoneEvent;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setTripZoneAction() as the \e action parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_TZ_ACTION_HIGH_Z  = 0,                 /* High-impedance output                        */
    EPWM_TZ_ACTION_HIGH    = 1,                 /* Force ePWM output to a high state            */
    EPWM_TZ_ACTION_LOW     = 2,                 /* Force ePWM output to a low state             */
    EPWM_TZ_ACTION_DISABLE = 3                  /* No action is taken on ePWM output            */
} EPWM_TripZoneAction;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_enableTripZoneInterrupt() and
 * \e EPWM_disableTripZoneInterrupt() as the \e source parameter.
 * 
 *************************************************************************************************/

#define EPWM_TZ_INTERRUPT_CBC           0x0002U     /* Cycle by cycle trip-zone interrupt       */
#define EPWM_TZ_INTERRUPT_OST           0x0004U     /* One shot trip-zone interrupt             */
#define EPWM_TZ_INTERRUPT_DCAEVT1       0x0008U     /* Digital compare A event 1 interrupt      */
#define EPWM_TZ_INTERRUPT_DCAEVT2       0x0010U     /* Digital compare A event 2 interrupt      */
#define EPWM_TZ_INTERRUPT_DCBEVT1       0x0020U     /* Digital compare B event 1 interrupt      */
#define EPWM_TZ_INTERRUPT_DCBEVT2       0x0040U     /* Digital compare B event 2 interrupt      */

/**************************************************************************************************
 * 
 * Values that can be returned by \e EPWM_getTripZoneFlagStatus().
 * 
 *************************************************************************************************/

#define EPWM_TZ_FLAG_CBC                0x0002U     /* Cycle by cycle trip-zone flag            */
#define EPWM_TZ_FLAG_OST                0x0004U     /* One shot trip-zone flag                  */
#define EPWM_TZ_FLAG_DCAEVT1            0x0008U     /* Digital compare A event 1 flag           */
#define EPWM_TZ_FLAG_DCAEVT2            0x0010U     /* Digital compare A event 2 flag           */
#define EPWM_TZ_FLAG_DCBEVT1            0x0020U     /* Digital compare B event 1 flag           */
#define EPWM_TZ_FLAG_DCBEVT2            0x0040U     /* Digital compare B event 2 flag           */

/**************************************************************************************************
 * 
 * Value can be passed to \e EPWM_clearTripZoneFlag() as the \e source parameter, and returned by
 * \e EPWM_getTripZoneFlagStatus().
 * 
 *************************************************************************************************/

#define EPWM_TZ_INTERRUPT               0x0001U     /* Trip-zone interrupt                      */

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_forceTripZoneEvent() as the \e event parameter.
 * 
 *************************************************************************************************/

#define EPWM_TZ_FORCE_EVENT_CBC         0x0002U     /* Force cycle by cycle trip event          */
#define EPWM_TZ_FORCE_EVENT_OST         0x0004U     /* Force one shot trip event                */
#define EPWM_TZ_FORCE_EVENT_DCAEVT1     0x0008U     /* Force digital compare output A event 1   */
#define EPWM_TZ_FORCE_EVENT_DCAEVT2     0x0010U     /* Force digital compare output A event 2   */
#define EPWM_TZ_FORCE_EVENT_DCBEVT1     0x0020U     /* Force digital compare output B event 1   */
#define EPWM_TZ_FORCE_EVENT_DCBEVT2     0x0040U     /* Force digital compare output B event 2   */

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setInterruptSource() as the \e source parameter.
 * 
 *************************************************************************************************/

#define EPWM_INT_TBCTR_ZERO             0x0001U     /* TBCTR equal to zero                      */
#define EPWM_INT_TBCTR_PERIOD           0x0002U     /* TBCTR equal to period                    */
#define EPWM_INT_TBCTR_ZERO_OR_PERIOD   0x0003U     /* TBCTR equal to zero or period            */
#define EPWM_INT_TBCTR_U_CMPA           0x0004U     /* TBCTR equal to CMPA on up count          */
#define EPWM_INT_TBCTR_D_CMPA           0x0005U     /* TBCTR equal to CMPA on down count        */
#define EPWM_INT_TBCTR_U_CMPB           0x0006U     /* TBCTR equal to CMPB on up count          */
#define EPWM_INT_TBCTR_D_CMPB           0x0007U     /* TBCTR equal to CMPB on down count        */

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_enableADCTrigger(), \e EPWM_disableADCTrigger(),
 * \e EPWM_setADCTriggerSource(), \e EPWM_setADCTriggerEventPrescale(),
 * \e EPWM_getADCTriggerFlagStatus(), \e EPWM_clearADCTriggerFlag(),
 * \e EPWM_getADCTriggerEventCount() and \e EPWM_forceADCTrigger() as the \e type parameter.
 * 
 *************************************************************************************************/

typedef enum {
    EPWM_SOC_A = 0,                                 /* ADC start-of-conversion A line           */
    EPWM_SOC_B = 1                                  /* ADC start-of-conversion B line           */
} EPWM_ADCStartOfConversionType;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setADCTriggerSource() as the \e source parameter.
 * 
 *************************************************************************************************/

typedef enum {
    EPWM_SOC_DCxEVT1              = 0,      /* Event is based on DCxEVT1                        */
    EPWM_SOC_TBCTR_ZERO           = 1,      /* TBCTR equals to zero                             */
    EPWM_SOC_TBCTR_PERIOD         = 2,      /* TBCTR equals to period                           */
    EPWM_SOC_TBCTR_ZERO_OR_PERIOD = 3,      /* TBCTR equals to zero or period                   */
    EPWM_SOC_TBCTR_U_CMPA         = 4,      /* TBCTR equals to CMPA on up count                 */
    EPWM_SOC_TBCTR_D_CMPA         = 5,      /* TBCTR equals to CMPA on down count               */
    EPWM_SOC_TBCTR_U_CMPB         = 6,      /* TBCTR equals to CMPB on up count                 */
    EPWM_SOC_TBCTR_D_CMPB         = 7       /* TBCTR equals to CMPB on down count               */
} EPWM_ADCStartOfConversionSource;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_selectDigitalCompareTripInput() as the \e type parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_TYPE_DCAH = 0,                  /* Digital compare A high                           */
    EPWM_DC_TYPE_DCAL = 1,                  /* Digital compare A low                            */
    EPWM_DC_TYPE_DCBH = 2,                  /* Digital compare B high                           */
    EPWM_DC_TYPE_DCBL = 3                   /* Digital compare B low                            */
} EPWM_DigitalCompareType;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_selectDigitalCompareTripInput() as the \e input parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_TRIP_TRIPIN1     = 0,           /* Trip 1                                           */
    EPWM_DC_TRIP_TRIPIN2     = 1,           /* Trip 2                                           */
    EPWM_DC_TRIP_TRIPIN3     = 2,           /* Trip 3                                           */
    EPWM_DC_TRIP_TRIPIN4     = 3,           /* Trip 4                                           */
    EPWM_DC_TRIP_TRIPIN5     = 4,           /* Trip 5                                           */
    EPWM_DC_TRIP_TRIPIN6     = 5,           /* Trip 6                                           */
    EPWM_DC_TRIP_TRIPIN7     = 6,           /* Trip 7                                           */
    EPWM_DC_TRIP_TRIPIN8     = 7,           /* Trip 8                                           */
    EPWM_DC_TRIP_TRIPIN9     = 8,           /* Trip 9                                           */
    EPWM_DC_TRIP_TRIPIN10    = 9,           /* Trip 10                                          */
    EPWM_DC_TRIP_TRIPIN11    = 10,          /* Trip 11                                          */
    EPWM_DC_TRIP_TRIPIN12    = 11,          /* Trip 12                                          */
    EPWM_DC_TRIP_TRIPIN13    = 12,          /* Trip 13                                          */
    EPWM_DC_TRIP_TRIPIN14    = 13,          /* Trip 14                                          */
    EPWM_DC_TRIP_TRIPIN15    = 14,          /* Trip 15                                          */
    EPWM_DC_TRIP_COMBINATION = 15           /* All trips (Trip 1..15) are selected              */
} EPWM_DigitalCompareTripInput;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareBlankingEvent() as the \e pulse parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_WINDOW_START_TBCTR_PERIOD      = 0,     /* TBCTR equals to period                   */
    EPWM_DC_WINDOW_START_TBCTR_ZERO        = 1      /* TBCTR equals to zero                     */
} EPWM_DigitalCompareBlankingPulse;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareFilterInput() as the \e input parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_WINDOW_SOURCE_DCAEVT1 = 0,          /* Digital compare filter source is DCAEVT1     */
    EPWM_DC_WINDOW_SOURCE_DCAEVT2 = 1,          /* Digital compare filter source is DCAEVT2     */
    EPWM_DC_WINDOW_SOURCE_DCBEVT1 = 2,          /* Digital compare filter source is DCBEVT1     */
    EPWM_DC_WINDOW_SOURCE_DCBEVT2 = 3           /* Digital compare filter source is DCBEVT2     */
} EPWM_DigitalCompareFilterInput;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareEventSource(),
 * \e EPWM_setDigitalCompareEventSyncMode(), \e EPWM_enableDigitalCompareADCTrigger(),
 * \e EPWM_disableDigitalCompareADCTrigger(), \e EPWM_enableDigitalCompareSyncEvent(),
 * and \e EPWM_disableDigitalCompareSyncEvent() as the \e module parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_MODULE_A = 0,                       /* Digital compare module A                     */
    EPWM_DC_MODULE_B = 1                        /* Digital compare module B                     */
} EPWM_DigitalCompareModule;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareEventSource() and
 * \e EPWM_setDigitalCompareEventSyncMode() as the \e event parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_EVENT_1 = 0,                        /* Digital compare event number 1               */
    EPWM_DC_EVENT_2 = 1                         /* Digital compare event number 2               */
} EPWM_DigitalCompareEvent;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareEventSource() as the \e source parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_EVENT_SOURCE_ORIG_SIGNAL = 0,       /* Signal source is not filtered (DCAEVT1/2)    */
    EPWM_DC_EVENT_SOURCE_FILT_SIGNAL = 1        /* Signal source is filtered (DCEVTFILT)        */
} EPWM_DigitalCompareEventSource;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_setDigitalCompareEventSyncMode() as the \e mode parameter.
 * 
 *************************************************************************************************/
typedef enum {
    EPWM_DC_EVENT_INPUT_SYNCED     = 0,         /* Input signal is synced with TBCLK            */
    EPWM_DC_EVENT_INPUT_NOT_SYNCED = 1          /* Input signal is not synced with TBCLK        */
} EPWM_DigitalCompareSyncMode;

/**************************************************************************************************
 * 
 * Values that can be passed to \e EPWM_configureSignal() as the \e signal parameter.
 * 
 *************************************************************************************************/
typedef struct {
    float32_t freqInHz;                         /* Desired signal frequency in Hz               */
    float32_t dutyValA;                         /* Desired ePWMxA signal duty cycle             */
    float32_t dutyValB;                         /* Desired ePWMxB signal duty cycle             */
    bool invertSignalB;                         /* Invert ePWMxB signal if true                 */
    float32_t sysClkInHz;                       /* SYSCLK frequency in Hz                       */
    EPWM_TimeBaseCountMode tbCtrMode;           /* Time-base counter mode                       */
    EPWM_ClockDivider tbClkDiv;                 /* Time-base counter clock divider              */
    EPWM_HSClockDivider tbHSClkDiv;             /* Time-base counter high-speed clock divider   */
} EPWM_SignalParams;

/**************************************************************************************************
 * 
 * Prototypes for the APIs
 * 
 *************************************************************************************************/

#ifdef DEBUG
/**************************************************************************************************
 * 
 * \brief Checks ePWM module base address
 * 
 * \param base base address of the ePWM module
 * 
 * \return \b true if the ePWM module base address is valid
 * 
 *************************************************************************************************/
static inline bool
EPWM_isBaseValid(uint32_t base)
{
    return (
        (base == EPWM1_BASE) ||
        (base == EPWM2_BASE) ||
        (base == EPWM3_BASE) ||
        (base == EPWM4_BASE) ||
        (base == EPWM5_BASE) ||
        (base == EPWM6_BASE) ||
        (base == EPWM7_BASE)
    );
}
#endif

/**************************************************************************************************
 * 
 * \brief Sets the time-base count
 * 
 * \param base base address of the EPWM module
 * \param count time base count value
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setTimeBaseCounter(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET(base, EPWM, TBCTR, count);
}

/**************************************************************************************************
 * 
 * \brief Set count mode after phase shift sync
 * 
 * \param base base address of the EPWM module
 * \param mode count mode
 * 
 * \details This function sets the time base to count up or down after new phase value set by the
 * \e EPWM_setPhaseShift() function. The count direction is determined by the \e mode parameter:
 * - \b EPWM_COUNT_MODE_DOWN_AFTER_SYNC
 * - \b EPWM_COUNT_MODE_UP_AFTER_SYNC
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setCountModeAfterSync(uint32_t base, EPWM_SyncCountMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    if (mode == EPWM_COUNT_MODE_UP_AFTER_SYNC) {
        HW_BIT_SET(base, EPWM, TBCTL, PHSDIR);
    } else { /* mode == EPWM_COUNT_MODE_DOWN_AFTER_SYNC */
        HW_BIT_CLR(base, EPWM, TBCTL, PHSDIR);
    }
}

/**************************************************************************************************
 * 
 * \brief Set the time-base clock prescalers
 * 
 * \param base base address of the EPWM module
 * \param clkdiv time-base count prescale value
 * \param hspclkdiv high-speed time-base count prescale value
 * 
 * \details This function sets prescaler (divider) values for the time-base clock counter. The
 * ePWM output clock is defined as TBCLK = EPWMCLK / (clkdiv * hspclkdiv), where EPWMCLK is a
 * scaled version of SYSCLK. At reset EPWMCLK is half the SYSCLK.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setClockPrescaler(uint32_t base, EPWM_ClockDivider clkdiv, EPWM_HSClockDivider hspclkdiv)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_FLD_SET(base, EPWM, TBCTL, CLKDIV, clkdiv);
    HW_FLD_SET(base, EPWM, TBCTL, HSPCLKDIV, hspclkdiv);
}

/**************************************************************************************************
 * 
 * \brief Force a software sync pulse
 * 
 * \param base base address of the EPWM module
 * 
 * \details This function causes a single software initiated sync pulse. Make sure the appropriate
 * mode is selected using \e EPWM_setupSyncOutputMode() before using this function.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_forceSyncPulse(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, TBCTL, SWFSYNC);
}

/**************************************************************************************************
 * 
 * \brief Setup sync out pulse event
 * 
 * \param base base address of the EPWM module
 * \param mode sync out mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setSyncOutPulseMode(uint32_t base, EPWM_SyncOutPulseMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_FLD_SET(base, EPWM, TBCTL, SYNCOSEL, mode);
}

/**************************************************************************************************
 * 
 * \brief Set PWM period load mode
 * 
 * \param base base address of the EPWM module
 * \param mode PWM period load mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setPeriodLoadMode(uint32_t base, EPWM_PeriodLoadMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    if (mode == EPWM_PERIOD_SHADOW_LOAD) {
        HW_BIT_CLR(base, EPWM, TBCTL, PRDLD);
    } else { /* mode == EPWM_PERIOD_DIRECT_LOAD */
        HW_BIT_SET(base, EPWM, TBCTL, PRDLD);
    }
}

/**************************************************************************************************
 * 
 * \brief Enable phase shift load
 * 
 * \param base base address of the EPWM module
 * 
 * \details This function enables loading of phase shift when the appropriate sync event occurs.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enablePhaseShiftLoad(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, TBCTL, PHSEN);
}

/**************************************************************************************************
 * 
 * \brief Disable phase shift load
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disablePhaseShiftLoad(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_CLR(base, EPWM, TBCTL, PHSEN);
}

/**************************************************************************************************
 * 
 * \brief Set time-base counter mode
 * 
 * \param base base address of the EPWM module
 * \param mode time-base counter mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setTimeBaseCounterMode(uint32_t base, EPWM_TimeBaseCountMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_FLD_SET(base, EPWM, TBCTL, CTRMODE, mode);
}

/**************************************************************************************************
 * 
 * \brief Returns time-base counter value
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getTimeBaseCounterValue(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_REG_GET(base, EPWM, TBCTR);
}

/**************************************************************************************************
 * 
 * \brief Return time-base counter maximum status
 * 
 * \param base base address of the EPWM module
 * 
 * \return \b true if counter has reached \b 0xFFFFU; \b false otherwise
 * 
 *************************************************************************************************/
static inline bool
EPWM_getTimeBaseCounterOverflowStatus(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_BIT_GET(base, EPWM, TBSTS, CTRMAX);
}

/**************************************************************************************************
 * 
 * \brief Clears max time-base counter event
 * 
 * \param base base address of the EPWM module
 * 
 * \details This function clears the max time-base counter latch event. The latch event occurs
 * when the time-base counter reaches its maximum value of \b 0xFFFFU.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_clearTimeBaseCounterOverflowEvent(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET_BIT(base, EPWM, TBSTS, 2U);
}

/**************************************************************************************************
 * 
 * \brief Return external sync signal status
 * 
 * \param base base address of the EPWM module
 * 
 * \return \b true if there was an external sync signal event; \b false otherwise
 * 
 *************************************************************************************************/
static inline bool
EPWM_getSyncStatus(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_BIT_GET(base, EPWM, TBSTS, SYNCI);
}

/**************************************************************************************************
 * 
 * \brief Clear external sync signal event
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_clearSyncEvent(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET_BIT(base, EPWM, TBSTS, 1U);
}

/**************************************************************************************************
 * 
 * \brief Return time-base counter direction
 * 
 * \param base base address of the EPWM module
 * 
 * \return \b EPWM_TIME_BASE_STATUS_COUNT_DOWN or \b EPWM_TIME_BASE_STATUS_COUNT_UP
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getTimeBaseCounterDirection(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return (uint16_t) HW_BIT_GET(base, EPWM, TBSTS, CTRDIR);
}

/**************************************************************************************************
 * 
 * \brief Set the phase shift offset counter value
 * 
 * \param base base address of the EPWM module
 * \param count phase shift value
 * 
 * \details This function sets the 16-bit time-base counter phase of the ePWM relative to the time-
 * base that is supplying the synchronization input signal. Call the \e EPWM_enablePhaseShiftLoad()
 * function to enable loading of the \e count phase shift value when a sync event occurs.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setPhaseShift(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET(base, EPWM, TBPHS, count);
}

/**************************************************************************************************
 * 
 * \brief Sets the PWM period count
 * 
 * \param base base address of the EPWM module
 * \param count period count value
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setTimeBasePeriod(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET(base, EPWM, TBPRD, count);
}

/**************************************************************************************************
 * 
 * \brief Gets the PWM period count
 * 
 * \param base base address of the EPWM module
 * 
 * \return The period count value
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getTimeBasePeriod(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_REG_GET(base, EPWM, TBPRD);
}

/**************************************************************************************************
 * 
 * \brief Setup counter compare shadow load mode
 * 
 * \param base base address of the EPWM module
 * \param module counter compare module
 * \param mode shadow to active load mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setCounterCompareShadowLoadMode(uint32_t base, EPWM_CounterCompareModule module,
    EPWM_CounterCompareLoadMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    if (module == EPWM_COUNTER_COMPARE_A) {
        HW_BIT_CLR(base, EPWM, CMPCTL, SHDWAMODE);
        HW_FLD_SET(base, EPWM, CMPCTL, LOADAMODE, mode);
    } else { /* module == EPWM_COUNTER_COMPARE_B */
        HW_BIT_CLR(base, EPWM, CMPCTL, SHDWBMODE);
        HW_FLD_SET(base, EPWM, CMPCTL, LOADBMODE, mode);
    }
}

/**************************************************************************************************
 * 
 * \brief Disable counter compare shadow load mode
 * 
 * \param base base address of the EPWM module
 * \param module counter compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableCounterCompareShadowLoadMode(uint32_t base, EPWM_CounterCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    if (module == EPWM_COUNTER_COMPARE_A) {
        HW_BIT_SET(base, EPWM, CMPCTL, SHDWAMODE);
    } else { /* module == EPWM_COUNTER_COMPARE_B */
        HW_BIT_SET(base, EPWM, CMPCTL, SHDWBMODE);
    }
}

/**************************************************************************************************
 * 
 * \brief Set counter compare value
 * 
 * \param base base address of the EPWM module
 * \param module counter compare module
 * \param count counter compare count value
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setCounterCompareValue(uint32_t base, EPWM_CounterCompareModule module, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));

    if (module == EPWM_COUNTER_COMPARE_A) {
        HW_REG_SET(base, EPWM, CMPA, count);
    } else { /* module == EPWM_COUNTER_COMPARE_B */
        HW_REG_SET(base, EPWM, CMPB, count);
    }
}

/**************************************************************************************************
 * 
 * \brief Get counter compare value
 * 
 * \param base base address of the EPWM module
 * \param module counter compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getCounterCompareValue(uint32_t base, EPWM_CounterCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    if (module == EPWM_COUNTER_COMPARE_A) {
        return HW_REG_GET(base, EPWM, CMPA);
    } else { /* module == EPWM_COUNTER_COMPARE_B */
        return HW_REG_GET(base, EPWM, CMPB);
    }
}

/**************************************************************************************************
 * 
 * \brief Get counter compare shadow register full status
 * 
 * \param base base address of the EPWM module
 * \param module counter compare module
 * 
 * \return \b true if shadow register is full; \b false otherwise
 * 
 *************************************************************************************************/
static inline bool
EPWM_getCounterCompareShadowStatus(uint32_t base, EPWM_CounterCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    if (module == EPWM_COUNTER_COMPARE_A) {
        return HW_BIT_GET(base, EPWM, CMPCTL, SHDWAFULL);
    } else { /* module == EPWM_COUNTER_COMPARE_B */
        return HW_BIT_GET(base, EPWM, CMPCTL, SHDWBFULL);
    }
}

/**************************************************************************************************
 * 
 * \brief Setup action qualifier output
 * 
 * \param base base address of the EPWM module
 * \param type ePWM pin type
 * \param output action qualifier output
 * \param event event that causes change in output
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setActionQualifierAction(uint32_t base, EPWM_ActionQualifierOutputModule type,
    EPWM_ActionQualifierOutput output, EPWM_ActionQualifierOutputEvent event)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t reg;

    uint16_t mask = 0x3U << event;
    uint16_t value = (output << event) & mask;

    if (type == EPWM_AQ_OUTPUT_A) {
        reg = HW_REG_GET(base, EPWM, AQCTLA);
        HW_REG_SET(base, EPWM, AQCTLA, ((reg & ~mask) | value));
    } else { /* type == EPWM_AQ_OUTPUT_B */
        reg = HW_REG_GET(base, EPWM, AQCTLB);
        HW_REG_SET(base, EPWM, AQCTLB, ((reg & ~mask) | value));
    }
}

/**************************************************************************************************
 * 
 * \brief Setup action qualifier event outputs
 * 
 * \param base base address of the EPWM module
 * \param type ePWM pin type
 * \param action desired action when specified event occurs
 * 
 * \details This function setups action qualifier output on ePWMA or ePWMB to a value specified by
 * the \e action parameter. The \e action parameter is formed as OR between enumerated values from
 * \e EPWM_ActionQualifierEventAction enumeration.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setActionQualifierActionComplete(uint32_t base, EPWM_ActionQualifierOutputModule type,
    uint16_t action)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_AQ_OUTPUT_A) {
        HW_REG_SET(base, EPWM, AQCTLA, action);
    } else { /* type == EPWM_AQ_OUTPUT_B */
        HW_REG_SET(base, EPWM, AQCTLB, action);
    }
}

/**************************************************************************************************
 * 
 * \brief Setup one-time software force action qualifier output
 * 
 * \param base base address of the EPWM module
 * \param type ePWM pin type
 * \param output action qualifier output
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setActionQualifierSWAction(uint32_t base, EPWM_ActionQualifierOutputModule type,
    EPWM_ActionQualifierOutput output)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_AQ_OUTPUT_A) {
        HW_FLD_SET(base, EPWM, AQSFRC, ACTSFA, output);
    } else { /* type == EPWM_AQ_OUTPUT_B */
        HW_FLD_SET(base, EPWM, AQSFRC, ACTSFB, output);
    }
}

/**************************************************************************************************
 * 
 * \brief Setup action qualifier continuous software load mode
 * 
 * \param base base address of the EPWM module
 * \param mode shadow to active register load mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setActionQualifierContSWForceShadowMode(uint32_t base, EPWM_ActionQualifierContForce mode)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_FLD_SET(base, EPWM, AQSFRC, RLDCSF, mode);
}

/**************************************************************************************************
 * 
 * \brief Triggers a continuous software forced event
 * 
 * \param base base address of the EPWM module
 * \param type ePWM pin type
 * \param output action qualifier output
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setActionQualifierContSWForceAction(uint32_t base, EPWM_ActionQualifierOutputModule type,
    EPWM_ActionQualifierSWOutput output)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_AQ_OUTPUT_A) {
        HW_FLD_SET(base, EPWM, AQCSFRC, CSFA, output);
    } else { /* type == EPWM_AQ_OUTPUT_B */
        HW_FLD_SET(base, EPWM, AQCSFRC, CSFB, output);
    }
}

/**************************************************************************************************
 * 
 * \brief Triggers one-time software forces event on action qualifier
 * 
 * \param base base address of the EPWM module
 * \param type ePWM pin type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_forceActionQualifierSWAction(uint32_t base, EPWM_ActionQualifierOutputModule type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_AQ_OUTPUT_A) {
        HW_BIT_SET(base, EPWM, AQSFRC, OTSFA);
    } else { /* type == EPWM_AQ_OUTPUT_B */
        HW_BIT_SET(base, EPWM, AQSFRC, OTSFB);
    }
}

/**************************************************************************************************
 * 
 * \brief Sets dead-band signal output mode
 * 
 * \param base base address of the EPWM module
 * \param mode dead-band delay type
 * \param enable enable or disable dead-band insertion
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDeadBandDelayMode(uint32_t base, EPWM_DeadBandDelayMode mode, bool enable)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t shift = EPWM_DBCTL_OUTMODE_S + mode;

    uint16_t mask = 1U << shift;

    uint16_t reg = HW_REG_GET(base, EPWM, DBCTL);

    if (enable) {
        reg |= mask;
    } else { /* !enable */
        reg &= ~mask;
    }

    HW_REG_SET(base, EPWM, DBCTL, reg);
}

/**************************************************************************************************
 * 
 * \brief Sets dead-band delay polarity
 * 
 * \param base base address of the EPWM module
 * \param mode dead-band delay type
 * \param polarity polarity of the delayed signal
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDeadBandDelayPolarity(uint32_t base, EPWM_DeadBandDelayMode mode,
    EPWM_DeadBandPolarity polarity)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t shift = (mode ^ 0x1U) + EPWM_DBCTL_POLSEL_S;

    uint16_t mask = 1U << shift;
    uint16_t value = polarity << shift;

    uint16_t reg = HW_REG_GET(base, EPWM, DBCTL);
    HW_REG_SET(base, EPWM, DBCTL, ((reg & ~mask) | value));
}

/**************************************************************************************************
 * 
 * \brief Sets input to rising-edge dead-band insertion block
 * 
 * \param base base address of the EPWM module
 * \param input signal to the insertion block
 * 
 * \details This function sets input to the rising-edge dead-band insertion block. Valid values
 * for the \e input parameter are as follows:
 * - \b EPWM_DB_INPUT_EPWMA
 * - \b EPWM_DB_INPUT_EPWMB
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setRisingEdgeDeadBandDelayInput(uint32_t base, uint16_t input)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((input == EPWM_DB_INPUT_EPWMA) || (input == EPWM_DB_INPUT_EPWMB));

    uint16_t shift = EPWM_DBCTL_INMODE_S + 0U;

    uint16_t mask = 1U << shift;
    uint16_t value = input << shift;

    uint16_t reg = HW_REG_GET(base, EPWM, DBCTL);
    HW_REG_SET(base, EPWM, DBCTL, ((reg & ~mask) | value));
}

/**************************************************************************************************
 * 
 * \brief Sets input to falling-edge dead-band insertion block
 * 
 * \param base base address of the EPWM module
 * \param input input signal to the insertion block
 * 
 * \details This function sets input to the falling-edge dead-band insertion block. Valid values
 * for the \e input parameter are as follows:
 * - \b EPWM_DB_INPUT_EPWMA
 * - \b EPWM_DB_INPUT_EPWMB
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setFallingEdgeDeadBandDelayInput(uint32_t base, uint16_t input)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((input == EPWM_DB_INPUT_EPWMA) || (input == EPWM_DB_INPUT_EPWMB));

    uint16_t shift = EPWM_DBCTL_INMODE_S + 1U;

    uint16_t mask = 1U << shift;
    uint16_t value = input << shift;

    uint16_t reg = HW_REG_GET(base, EPWM, DBCTL);
    HW_REG_SET(base, EPWM, DBCTL, ((reg & ~mask) | value));
}

/**************************************************************************************************
 * 
 * \brief Sets dead-band counter clock mode with respect to ePWM time-base counter
 * 
 * \param base base address of the EPWM module
 * \param mode dead-band counter clock mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDeadBandCounterClock(uint32_t base, EPWM_DeadBandClockMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    if (mode == EPWM_DB_COUNTER_CLOCK_FULL_CYCLE) {
        HW_BIT_CLR(base, EPWM, DBCTL, HALFCYCLE);
    } else { /* mode == EPWM_DB_COUNTER_CLOCK_HALF_CYCLE */
        HW_BIT_SET(base, EPWM, DBCTL, HALFCYCLE);
    }
}

/**************************************************************************************************
 * 
 * \brief Set ePWM rising edge delay count
 * 
 * \param base base address of the EPWM module
 * \param count rising edge delay count
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setRisingEdgeDelayCount(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(count < 0x4000U);

    HW_FLD_SET(base, EPWM, DBRED, DEL, count);
}

/**************************************************************************************************
 * 
 * \brief Set ePWM falling edge delay count
 * 
 * \param base base address of the EPWM module
 * \param count rising edge delay count
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setFallingEdgeDelayCount(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(count < 0x4000U);

    HW_FLD_SET(base, EPWM, DBFED, DEL, count);
}

/**************************************************************************************************
 * 
 * \brief Enable chopper mode
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableChopper(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, PCCTL, CHPEN);
}

/**************************************************************************************************
 * 
 * \brief Disable chopper mode
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableChopper(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));
    
    HW_BIT_CLR(base, EPWM, PCCTL, CHPEN);
}

/**************************************************************************************************
 * 
 * \brief Set chopper duty cycle
 * 
 * \param base base address of the EPWM module
 * \param count chopping clock duty-cycle count
 * 
 * \details This function sets the chopping clock duty-cycle. The \e count parameter value should
 * be less than 7. The actual chopper duty-cycle is defined as:
 *      DUTY = (count + 1) / 8
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setChopperDutyCycle(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(count < 7U);

    HW_FLD_SET(base, EPWM, PCCTL, CHPDUTY, count);
}

/**************************************************************************************************
 * 
 * \brief Set chopper clock frequency scaler
 * 
 * \param base base address of the EPWM module
 * \param divider chopping clock frequency divider
 * 
 * \details This function sets scaler for the chopping clock frequency. The \e divider parameter
 * value should be less than 8. The chopping clock frequency is defined as
 *      FREQUENCY = SYSCLKOUT / (divider + 1)
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setChopperFreq(uint32_t base, uint16_t divider)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(divider < 8U);

    HW_FLD_SET(base, EPWM, PCCTL, CHPFREQ, divider);
}

/**************************************************************************************************
 * 
 * \brief Set width for first pulse of chopper output waveform
 * 
 * \param base base address of the EPWM module
 * \param width width for first pulse
 * 
 * \details This function sets width for first pulse of chopper output waveform. The \e width
 * parameter value should be less than 16U. The actual width of the first pulse is
 *      WIDTH = 8 / ((width + 1) * SYSCLKOUT)
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setChopperFirstPulseWidth(uint32_t base, uint16_t width)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(width < 16U);

    HW_FLD_SET(base, EPWM, PCCTL, OSHTWTH, width);
}

/**************************************************************************************************
 * 
 * \brief Enables trip-zone signal
 * 
 * \param base base address of the EPWM module
 * \param signal trip-zone signal
 * 
 * \details This function enables the trip-zone signal. The \e signal parameter is logical OR
 * between any of the following:
 * - \b EPWM_TZ_SIGNAL_CBC1
 * - \b EPWM_TZ_SIGNAL_CBC2
 * - \b EPWM_TZ_SIGNAL_CBC3
 * - \b EPWM_TZ_SIGNAL_CBC4
 * - \b EPWM_TZ_SIGNAL_CBC5
 * - \b EPWM_TZ_SIGNAL_CBC6
 * - \b EPWM_TZ_SIGNAL_DCAEVT2
 * - \b EPWM_TZ_SIGNAL_DCBEVT2
 * - \b EPWM_TZ_SIGNAL_OSHT1
 * - \b EPWM_TZ_SIGNAL_OSHT2
 * - \b EPWM_TZ_SIGNAL_OSHT3
 * - \b EPWM_TZ_SIGNAL_OSHT4
 * - \b EPWM_TZ_SIGNAL_OSHT5
 * - \b EPWM_TZ_SIGNAL_OSHT6
 * - \b EPWM_TZ_SIGNAL_DCAEVT1
 * - \b EPWM_TZ_SIGNAL_DCBEVT1
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableTripZoneSignals(uint32_t base, uint16_t signal)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t reg = HW_REG_GET(base, EPWM, TZSEL);

    EALLOW;

    HW_REG_SET(base, EPWM, TZSEL, (reg | signal));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disables trip-zone signal
 * 
 * \param base base address of the EPWM module
 * \param signal trip-zone signal
 * 
 * \details This function disables the trip-zone signal. The \e signal parameter is logical OR
 * between any of the following:
 * - \b EPWM_TZ_SIGNAL_CBC1
 * - \b EPWM_TZ_SIGNAL_CBC2
 * - \b EPWM_TZ_SIGNAL_CBC3
 * - \b EPWM_TZ_SIGNAL_CBC4
 * - \b EPWM_TZ_SIGNAL_CBC5
 * - \b EPWM_TZ_SIGNAL_CBC6
 * - \b EPWM_TZ_SIGNAL_DCAEVT2
 * - \b EPWM_TZ_SIGNAL_DCBEVT2
 * - \b EPWM_TZ_SIGNAL_OSHT1
 * - \b EPWM_TZ_SIGNAL_OSHT2
 * - \b EPWM_TZ_SIGNAL_OSHT3
 * - \b EPWM_TZ_SIGNAL_OSHT4
 * - \b EPWM_TZ_SIGNAL_OSHT5
 * - \b EPWM_TZ_SIGNAL_OSHT6
 * - \b EPWM_TZ_SIGNAL_DCAEVT1
 * - \b EPWM_TZ_SIGNAL_DCBEVT1
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableTripZoneSignals(uint32_t base, uint16_t signal)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t reg = HW_REG_GET(base, EPWM, TZSEL);

    EALLOW;

    HW_REG_SET(base, EPWM, TZSEL, (reg & ~signal));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set digital compare conditions that cause trip-zone event
 * 
 * \param base base address of the EPWM module
 * \param output digital compare output type
 * \param event digital compare output event
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setTripZoneDigitalCompareEventCondition(uint32_t base,
    EPWM_TripZoneDigitalCompareOutput output, EPWM_TripZoneDigitalCompareOutputEvent event)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t mask = 0x7U << output;
    uint16_t value = (event << output) & mask;

    uint16_t reg = HW_REG_GET(base, EPWM, TZDCSEL);

    EALLOW;

    HW_REG_SET(base, EPWM, TZDCSEL, ((reg & ~mask) | value));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set trip-zone action
 * 
 * \param base base address of the EPWM module
 * \param event trip-zone event type
 * \param action trip-zone action
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setTripZoneAction(uint32_t base, EPWM_TripZoneEvent event, EPWM_TripZoneAction action)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t mask = 0x3U << event;
    uint16_t value = (action << event) & mask;

    uint16_t reg = HW_REG_GET(base, EPWM, TZCTL);

    EALLOW;

    HW_REG_SET(base, EPWM, TZCTL, ((reg & ~mask) | value));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable trip-zone interrupt source
 * 
 * \param base base address of the EPWM module
 * \param source trip-zone interrupt source
 * 
 * \details This function enables trip-zone interrupts. The \e source parameter is logical OR
 * between any of the following:
 * - \b EPWM_TZ_INTERRUPT_CBC
 * - \b EPWM_TZ_INTERRUPT_OST
 * - \b EPWM_TZ_INTERRUPT_DCAEVT1
 * - \b EPWM_TZ_INTERRUPT_DCAEVT2
 * - \b EPWM_TZ_INTERRUPT_DCBEVT1
 * - \b EPWM_TZ_INTERRUPT_DCBEVT2
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableTripZoneInterrupt(uint32_t base, uint16_t source)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((source > 0x01U) && (source < 0x80U));

    uint16_t reg = HW_REG_GET(base, EPWM, TZEINT);

    EALLOW;

    HW_REG_SET(base, EPWM, TZEINT, (reg | source));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disables trip-zone interrupt source
 * 
 * \param base base address of the EPWM module
 * \param source trip-zone interrupt source
 * 
 * \details This function disables trip-zone interrupts. The \e source parameter is logical OR
 * between any of the following:
 * - \b EPWM_TZ_INTERRUPT_CBC
 * - \b EPWM_TZ_INTERRUPT_OST
 * - \b EPWM_TZ_INTERRUPT_DCAEVT1
 * - \b EPWM_TZ_INTERRUPT_DCAEVT2
 * - \b EPWM_TZ_INTERRUPT_DCBEVT1
 * - \b EPWM_TZ_INTERRUPT_DCBEVT2
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableTripZoneInterrupt(uint32_t base, uint16_t source)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((source > 0x01U) && (source < 0x80U));

    uint16_t reg = HW_REG_GET(base, EPWM, TZEINT);

    EALLOW;

    HW_REG_SET(base, EPWM, TZEINT, (reg & ~source));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Get the trip-zone status flag
 * 
 * \param base base address of the EPWM module
 * 
 * \details This function returns trip-zone status flag as logical OR between any of the following:
 * - \b EPWM_TZ_INTERRUPT
 * - \b EPWM_TZ_FLAG_CBC
 * - \b EPWM_TZ_FLAG_OST
 * - \b EPWM_TZ_FLAG_DCAEVT1
 * - \b EPWM_TZ_FLAG_DCAEVT2
 * - \b EPWM_TZ_FLAG_DCBEVT1
 * - \b EPWM_TZ_FLAG_DCBEVT2
 * 
 * \return Trip-zone status flag
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getTripZoneFlagStatus(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_REG_GET(base, EPWM, TZFLG) & 0x7FU;
}

/**************************************************************************************************
 * 
 * \brief Clear trip-zone flag
 * 
 * \param base base address of the EPWM module
 * \param flags trip-zone flags
 * 
 * \details This function clears the trip-zone flags. The \e flags parameter is logical OR
 * between any of the following:
 * - \b EPWM_TZ_INTERRUPT
 * - \b EPWM_TZ_FLAG_CBC
 * - \b EPWM_TZ_FLAG_OST
 * - \b EPWM_TZ_FLAG_DCAEVT1
 * - \b EPWM_TZ_FLAG_DCAEVT2
 * - \b EPWM_TZ_FLAG_DCBEVT1
 * - \b EPWM_TZ_FLAG_DCBEVT2
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_clearTripZoneFlag(uint32_t base, uint16_t flags)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((flags > 0x00U) && (flags < 0x80U));

    EALLOW;

    HW_REG_SET(base, EPWM, TZCLR, flags);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Force trip-zone event
 * 
 * \param base base address of the EPWM module
 * \param event trip-zone event to force
 * 
 * \details This function forces a trip-zone event. The \e event parameter is logical OR between
 * any of the following:
 * - \b EPWM_TZ_FORCE_EVENT_CBC
 * - \b EPWM_TZ_FORCE_EVENT_OST
 * - \b EPWM_TZ_FORCE_EVENT_DCAEVT1
 * - \b EPWM_TZ_FORCE_EVENT_DCAEVT2
 * - \b EPWM_TZ_FORCE_EVENT_DCBEVT1
 * - \b EPWM_TZ_FORCE_EVENT_DCBEVT2
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_forceTripZoneEvent(uint32_t base, uint16_t event)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((event > 0x01U) && (event < 0x80U));

    EALLOW;

    HW_REG_SET(base, EPWM, TZFRC, event);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable ePWM interrupt
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableInterrupt(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, ETSEL, INTEN);
}

/**************************************************************************************************
 * 
 * \brief Disable ePWM interrupt
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableInterrupt(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_CLR(base, EPWM, ETSEL, INTEN);
}

/**************************************************************************************************
 * 
 * \brief Set ePWM interrupt source
 * 
 * \param base base address of the EPWM module
 * \param source ePWM interrupt source
 * 
 * \details This function sets the ePWM interrupt source. Valid values for the \e source parameter
 * are as follows:
 * - \b EPWM_INT_TBCTR_ZERO
 * - \b EPWM_INT_TBCTR_PERIOD
 * - \b EPWM_INT_TBCTR_ZERO_OR_PERIOD
 * - \b EPWM_INT_TBCTR_U_CMPA
 * - \b EPWM_INT_TBCTR_D_CMPA
 * - \b EPWM_INT_TBCTR_U_CMPB
 * - \b EPWM_INT_TBCTR_D_CMPB
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setInterruptSource(uint32_t base, uint16_t source)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT((source > 0x0U) && (source < 0x8U));

    HW_FLD_SET(base, EPWM, ETSEL, INTSEL, source);
}

/**************************************************************************************************
 * 
 * \brief Set the ePWM interrupt event count
 * 
 * \param base base address of the EPWM module
 * \param count event count for interrupt scale
 * 
 * \details This function sets the interrupt event count that determines the number of events that
 * have to occur before an interrupt is generated. Maximum value for \e count parameter is 3.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setInterruptEventCount(uint32_t base, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(count < 4U);

    HW_FLD_SET(base, EPWM, ETPS, INTPRD, count);
}

/**************************************************************************************************
 * 
 * \brief Return the interrupt status
 * 
 * \param base base address of the EPWM module
 * 
 * \return \b true if interrupt was generated; \b false otherwise
 * 
 *************************************************************************************************/
static inline bool
EPWM_getEventTriggerInterruptStatus(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_BIT_GET(base, EPWM, ETFLG, INT);
}

/**************************************************************************************************
 * 
 * \brief Clear interrupt flag
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_clearEventTriggerInterruptFlag(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, ETCLR, INT);
}

/**************************************************************************************************
 * 
 * \brief Force ePWM interrupt
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_forceEventTriggerInterrupt(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_BIT_SET(base, EPWM, ETFRC, INT);
}

/**************************************************************************************************
 * 
 * \brief Get the interrupt event count
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getInterruptEventCount(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_FLD_GET(base, EPWM, ETPS, INTCNT);
}

/**************************************************************************************************
 * 
 * \brief Enable ADC SOC event
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableADCTrigger(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        HW_BIT_SET(base, EPWM, ETSEL, SOCAEN);
    } else { /* type == EPWM_SOC_B */
        HW_BIT_SET(base, EPWM, ETSEL, SOCBEN);
    }
}

/**************************************************************************************************
 * 
 * \brief Disable ADC SOC event
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableADCTrigger(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        HW_BIT_CLR(base, EPWM, ETSEL, SOCAEN);
    } else { /* type == EPWM_SOC_B */
        HW_BIT_CLR(base, EPWM, ETSEL, SOCBEN);
    }
}

/**************************************************************************************************
 * 
 * \brief Sets the ePWM SOC source
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * \param source SOC source
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setADCTriggerSource(uint32_t base, EPWM_ADCStartOfConversionType type,
    EPWM_ADCStartOfConversionSource source)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        HW_FLD_SET(base, EPWM, ETSEL, SOCASEL, source);
    } else { /* type == EPWM_SOC_B */
        HW_FLD_SET(base, EPWM, ETSEL, SOCBSEL, source);
    }
}

/**************************************************************************************************
 * 
 * \brief Sets the ePWM SOC event counts
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * \param count event count number
 * 
 * \details This function sets the SOC event count that determines the number of events that have
 * to occur before an SOC is issued. The maximum \e count parameter value is 3. When the \e count
 * parameter equals 0, the trigger is disabled.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setADCTriggerEventPrescale(uint32_t base, EPWM_ADCStartOfConversionType type, uint16_t count)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(count < 4U);

    if (type == EPWM_SOC_A) {
        HW_FLD_SET(base, EPWM, ETPS, SOCAPRD, count);
    } else { /* type == EPWM_SOC_B */
        HW_FLD_SET(base, EPWM, ETPS, SOCBPRD, count);
    }
}

/**************************************************************************************************
 * 
 * \brief Return the SOC event status
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return \b true if SOC trigger was generated; \b false otherwise
 * 
 *************************************************************************************************/
static inline bool
EPWM_getADCTriggerFlagStatus(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        return HW_BIT_GET(base, EPWM, ETFLG, SOCA);
    } else { /* EPWM_SOC_B */
        return HW_BIT_GET(base, EPWM, ETFLG, SOCB);
    }
}

/**************************************************************************************************
 * 
 * \brief Clear SOC flag
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_clearADCTriggerFlag(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        HW_BIT_SET(base, EPWM, ETCLR, SOCA);
    } else { /* EPWM_SOC_B */
        HW_BIT_SET(base, EPWM, ETCLR, SOCB);
    }
}

/**************************************************************************************************
 * 
 * \brief Get the SOC event count
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return SOC event count
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getADCTriggerEventCount(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        return HW_FLD_GET(base, EPWM, ETPS, SOCACNT);
    } else { /* type == EPWM_SOC_B */
        return HW_FLD_GET(base, EPWM, ETPS, SOCBCNT);
    }
}

/**************************************************************************************************
 * 
 * \brief Force SOC event
 * 
 * \param base base address of the EPWM module
 * \param type ADC SOC type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_forceADCTrigger(uint32_t base, EPWM_ADCStartOfConversionType type)
{
    ASSERT(EPWM_isBaseValid(base));

    if (type == EPWM_SOC_A) {
        HW_BIT_SET(base, EPWM, ETFRC, SOCA);
    } else { /* type == EPWM_SOC_B */
        HW_BIT_SET(base, EPWM, ETFRC, SOCB);
    }
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare trip input
 * 
 * \param base base address of the EPWM module
 * \param input digital compare trip input
 * \param type digital compare type
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_selectDigitalCompareTripInput(uint32_t base, EPWM_DigitalCompareTripInput input,
    EPWM_DigitalCompareType type)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t shift = type << 2;

    uint16_t mask = 0xFU << shift;
    uint16_t value = (input << shift) & mask;

    uint16_t reg = HW_REG_GET(base, EPWM, DCTRIPSEL);

    EALLOW;

    HW_REG_SET(base, EPWM, DCTRIPSEL, ((reg & ~mask) | value));

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable digital compare filter blanking window
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableDigitalCompareBlankingWindow(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_SET(base, EPWM, DCFCTL, BLANKE);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disable digital compare filter blanking window
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableDigitalCompareBlankingWindow(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_CLR(base, EPWM, DCFCTL, BLANKE);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable digital compare window inverse mode
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableDigitalCompareWindowInverseMode(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_SET(base, EPWM, DCFCTL, BLANKINV);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disable digital compare window inverse mode
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableDigitalCompareWindowInverseMode(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_CLR(base, EPWM, DCFCTL, BLANKINV);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare filter blanking pulse
 * 
 * \param base base address of the EPWM module
 * \param pulse pulse that starts blanking window
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareBlankingEvent(uint32_t base, EPWM_DigitalCompareBlankingPulse pulse)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_FLD_SET(base, EPWM, DCFCTL, PULSESEL, pulse);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Setup the digital compare filter input
 * 
 * \param base base address of the EPWM module
 * \param input digital compare signal source
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareFilterInput(uint32_t base, EPWM_DigitalCompareFilterInput input)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_FLD_SET(base, EPWM, DCFCTL, SRCSEL, input);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare filter window offset
 * 
 * \param base base address of the EPWM module
 * \param offset blanking window offset length
 * 
 * \details This function sets the offset between window start pulse and blanking window in
 * TBCLK count.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareWindowOffset(uint32_t base, uint16_t offset)
{
    ASSERT(EPWM_isBaseValid(base));

    HW_REG_SET(base, EPWM, DCFOFFSET, offset);
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare filter window length
 * 
 * \param base base address of the EPWM module
 * \param length blanking window length
 * 
 * \details This function sets the digital compare filter blanking window length in TBCLK count.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareWindowLength(uint32_t base, uint16_t length)
{
    ASSERT(EPWM_isBaseValid(base));
    ASSERT(length < 0x800U);

    HW_FLD_SET(base, EPWM, DCFWINDOW, WINDOW, length);
}

/**************************************************************************************************
 * 
 * \brief Return digital compare filter blanking window offset count
 * 
 * \param base base address of the EPWM module
 * 
 * \return Blanking window offset count
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getDigitalCompareBlankingWindowOffsetCount(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_REG_GET(base, EPWM, DCFOFFSETCNT);
}

/**************************************************************************************************
 * 
 * \brief Return digital compare filter blanking window length count
 * 
 * \param base base address of the EPWM module
 * 
 * \return Blanking window length count
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getDigitalCompareBlankingWindowLengthCount(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_FLD_GET(base, EPWM, DCFWINDOWCNT, WINDOWCNT);
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare event source
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * \param event digital compare event number
 * \param source digital compare event source
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareEventSource(uint32_t base, EPWM_DigitalCompareModule module,
    EPWM_DigitalCompareEvent event, EPWM_DigitalCompareEventSource source)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t shift = 0U;
    if (event == EPWM_DC_EVENT_2) {
        shift = 8U;
    }

    uint16_t mask = 1U << shift;
    uint16_t value = (source << shift) & mask;

    uint16_t reg;

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        reg = HW_REG_GET(base, EPWM, DCACTL);
        HW_REG_SET(base, EPWM, DCACTL, ((reg & ~mask) | value));
    } else { /* module == EPWM_DC_MODULE_B */
        reg = HW_REG_GET(base, EPWM, DCBCTL);
        HW_REG_SET(base, EPWM, DCBCTL, ((reg & ~mask) | value));
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set the digital compare input sync mode
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * \param event digital compare event number
 * \param mode digital compare event sync mode
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareEventSyncMode(uint32_t base, EPWM_DigitalCompareModule module,
    EPWM_DigitalCompareEvent event, EPWM_DigitalCompareSyncMode mode)
{
    ASSERT(EPWM_isBaseValid(base));

    uint16_t shift = 1U;
    if (event == EPWM_DC_EVENT_2) {
        shift = 9U;
    }

    uint16_t mask = 1U << shift;
    uint16_t value = (mode << shift) & mask;

    uint16_t reg;

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        reg = HW_REG_GET(base, EPWM, DCACTL);
        HW_REG_SET(base, EPWM, DCACTL, ((reg & ~mask) | value));
    } else { /* module == EPWM_DC_MODULE_B */
        reg = HW_REG_GET(base, EPWM, DCBCTL);
        HW_REG_SET(base, EPWM, DCBCTL, ((reg & ~mask) | value));
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable digital compare to generate ADC start-of-conversion
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableDigitalCompareADCTrigger(uint32_t base, EPWM_DigitalCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        HW_BIT_SET(base, EPWM, DCACTL, EVT1SOCE);
    } else { /* module == EPWM_DC_MODULE_B */
        HW_BIT_SET(base, EPWM, DCBCTL, EVT1SOCE);
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disable digital compare to generate ADC start-of-conversion
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableDigitalCompareADCTrigger(uint32_t base, EPWM_DigitalCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        HW_BIT_CLR(base, EPWM, DCACTL, EVT1SOCE);
    } else { /* module == EPWM_DC_MODULE_B */
        HW_BIT_CLR(base, EPWM, DCBCTL, EVT1SOCE);
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable digital compare to generate sync out pulse
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableDigitalCompareSyncEvent(uint32_t base, EPWM_DigitalCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        HW_BIT_SET(base, EPWM, DCACTL, EVT1SYNCE);
    } else { /* module == EPWM_DC_MODULE_B */
        HW_BIT_SET(base, EPWM, DCBCTL, EVT1SYNCE);
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disable digital compare to generate sync out pulse
 * 
 * \param base base address of the EPWM module
 * \param module digital compare module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableDigitalCompareSyncEvent(uint32_t base, EPWM_DigitalCompareModule module)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    if (module == EPWM_DC_MODULE_A) {
        HW_BIT_CLR(base, EPWM, DCACTL, EVT1SYNCE);
    } else { /* module == EPWM_DC_MODULE_B */
        HW_BIT_CLR(base, EPWM, DCBCTL, EVT1SYNCE);
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Enable the time-base counter capture controller
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_enableDigitalCompareCounterCapture(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_SET(base, EPWM, DCCAPCTL, CAPE);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Disable the time-base counter capture controller
 * 
 * \param base base address of the EPWM module
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_disableDigitalCompareCounterCapture(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    HW_BIT_CLR(base, EPWM, DCCAPCTL, CAPE);

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Set the time-base counter capture mode
 * 
 * \param base base address of the EPWM module
 * \param mode shadow read mode flag
 * 
 * \details This function sets the mode the time-base counter value is read from. If \e mode is
 * \b true, CPU reads of the DCCAP register will return the shadow register contents. If \e mode
 * is \b false, CPU reads will return the active register contents.
 * 
 * \return None
 * 
 *************************************************************************************************/
static inline void
EPWM_setDigitalCompareCounterShadowMode(uint32_t base, bool mode)
{
    ASSERT(EPWM_isBaseValid(base));

    EALLOW;

    if (mode) {
        HW_BIT_CLR(base, EPWM, DCCAPCTL, SHDWMODE);
    } else { /* !mode */
        HW_BIT_SET(base, EPWM, DCCAPCTL, SHDWMODE);
    }

    EDIS;
}

/**************************************************************************************************
 * 
 * \brief Return the time-base counter capture value
 * 
 * \param base base address of the EPWM module
 * 
 * \return Time-base counter capture value
 * 
 *************************************************************************************************/
static inline uint16_t
EPWM_getDigitalCompareCaptureCount(uint32_t base)
{
    ASSERT(EPWM_isBaseValid(base));

    return HW_REG_GET(base, EPWM, DCCAP);
}

/**************************************************************************************************
 * 
 * \brief Set emulation mode
 * 
 * \param base base address of the EPWM module
 * \param mode emulation mode
 * 
 * \return None
 * 
 *************************************************************************************************/
extern void
EPWM_setEmulationMode(uint32_t base, EPWM_EmulationMode mode);

/**************************************************************************************************
 * 
 * \brief Configures ePWM signal with desired frequency and duty cycle
 * 
 * \param base base address of the EPWM module
 * \param signal desired signal parameters
 * 
 * \return None
 * 
 *************************************************************************************************/
extern void
EPWM_configureSignal(uint32_t base, const EPWM_SignalParams *signal);

#endif /* EPWM_H */
